---
title: "Portfolio Backtesting"
author: |
  | Daniel P. Palomar and Rui ZHOU
  | Hong Kong University of Science and Technology (HKUST)
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    base_format: prettydoc::html_pretty
    theme: tactile
    highlight: vignette
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_depth: 2
csl: ieee.csl
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{Portfolio Backtesting}
  %\VignetteKeyword{portfolio, backtest}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.retina = 2,
  out.width = "85%",
  dpi = 96,
  pngquant = "--speed=1"
)
knit_hooks$set(pngquant = hook_pngquant)
#Help on bookdown: https://bookdown.org/yihui/bookdown/
#rmarkdown::render("vignettes/PortfolioBacktest.Rmd", "bookdown::html_document2")
```

-----------
> This vignette illustrates the usage of the package `portfolioBacktest` for automated portfolio backtesting.
It can be used by a researcher/practitioner to check a set of different portfolios, as well as by a course 
instructor to evaluate the students in their portfolio design in a fully automated and convenient manner.


# Package Snapshot
This package backtests a list of portfolios over multiple datasets on a rolling-window basis, producing final results as in the following.
```{r, echo=FALSE}
library(portfolioBacktest)
load("figures/bt.RData")
```


* Performance table:

```{r, echo=FALSE}
res_sum <- backtestSummary(bt)
summaryTable(res_sum, type = "DT")
```

<br>

* Barplot:

```{r, echo=FALSE, out.width="75%"}
summaryBarPlot(res_sum, measures = c("Sharpe ratio", "max drawdown"), type = "ggplot2")
```

<br>

* Boxplot:

```{r, echo=FALSE, out.width="75%"}
backtestBoxPlot(bt, measure = "Sharpe ratio")
```

# Quick Start

Do the backtest on your own portfolio following few steps:
```{r, echo=FALSE, message=FALSE}
library(portfolioBacktest)
library(PerformanceAnalytics)
library(CVXR)
```

* **Step 1** - load package & dataset
```{r, results="hide"}
library(portfolioBacktest)
data("dataset10")
```
* **Step 2** - define your own portfolio
```{r}
my_portfolio <- function(dataset) {
  prices = dataset$adjusted
  N <- ncol(prices)
  return(rep(1/N, N))
}
```
* **Step 3** - do backtest
```{r, results="hide"}
bt <- portfolioBacktest(my_portfolio, dataset10)
```
* **Step 4** - check your portfolio performance
```{r}
backtestSummary(bt)$performance
```



# Installation
The package can currently be installed from [GitHub](https://github.com/dppalomar/portfolioBacktest):
```{r, eval=FALSE}
# install.packages("devtools")
devtools::install_github("dppalomar/portfolioBacktest")

# Getting help
library(portfolioBacktest)
help(package = "portfolioBacktest")
package?portfolioBacktest
?portfolioBacktest
```



# Loading Data

## Basic structure of datasets
The main function `portfolioBacktest()` requires argument `dataset_list` follow the certain format: it should be a list of several individual datasets, with each of them be a list of several xts objects following exactly same date index. Besides, each item must contain an xts recording the historical prices of all stocks. We have embedded a small formated dataset in this package, see follows
```{r}
data("dataset10")  # load the embedded dataset
class(dataset10)  # show dataset class
names(dataset10$`dataset 1`)  # structure of one dataset
head(dataset10$`dataset 1`$adjusted[, 1:3])  
```
Note that each data item contains an xts object called `"adjusted"` (adjusted prices). By default, `portfolioBacktest()` will use such `"adjusted"` prices to calculate the portfolio performance. But you can change this setting by passing another argument `price_name` to tell function which xts you want to use in calculating portfolio performance.

## Obtaining more data
We emphasize that 10 data is not enough in evaluating or comparing your portfolio functions. In this package, we provide a function `stockDataDownload()` to download online data resources. Its results will naturally follow our required data format. Function `stockDataResample()` can help do resampling from on a formated data and return a formated dataset, which can be directly passed to `portfolioBacktest()`. We recommend you to use these two functions in generating your own dataset, e.g.,
```{r, eval = FALSE}
data("SP500_symbols")  # load the SP500 symbols
# download data from internet
SP500 <- stockDataDownload(stock_symbols = SP500_symbols, 
                           from = "2008-12-01", to = "2018-12-01")
# resample from SP500, each with 50 stcoks and 2-year continuous data 
my_dataset_list <- stockDataResample(SP500_YAHOO, N_sample = 50, T_sample = 252*2, num_datasets = 10)
```
In each individual data item, you will get the 7 xts objects with name: `open`, `high`, `low`, `close`, `volume`, `adjusted`, `index`. You can save the dataset and use it everywhere as you want.

## Expanding the datasets

Knowing more can be helpful in designing portfolios. You are allowed to add as many other xts objects in each data item as you want. For example, if Moving Average Convergence Divergence (MACD) information is desired by portfolio functions, you can manually add it to dataset by
```{r, eval = FALSE}
for (i in 1:length(dataset10))
  dataset10[[i]]$MACD <- apply(dataset10[[i]]$adjusted, 2, function(x){TTR::MACD(x)[ ,'macd']})
```

# Defining Portfolios

The portfolio are required to be given in form of function, which will be fed with splited data and required to return a numerical vector of the same length to stocks number. We give the examples for **uniform portfolio**, **global minimum variance portfolio (GMVP)** and **Markowitz mean-variance portfolio** as follows (under practical constraints $\mathbf{w} \ge \mathbf{0}$ and $\mathbf{1}^{T} \mathbf{w} =1$)
```{r, echo = TRUE, results = 'hide'}
# define quintile portfolio
quintile_portfolio_fun <- function(data) {
  X <- diff(log(data$adjusted))[-1]  
  N <- ncol(X)
  ranking <- sort(colMeans(X), decreasing = TRUE, index.return = TRUE)$ix
  w <- rep(0, N)
  w[ranking[1:round(N/5)]] <- 1/round(N/5)
  return(w)
}

# define GMVP (allowing shorting)
GMVP_portfolio_fun <- function(data) {
  X <- diff(log(data$adjusted))[-1]  # compute log returns
  Sigma <- cov(X)  # compute SCM
  # design GMVP
  w <- solve(Sigma, rep(1, nrow(Sigma)))
  w <- w/sum(abs(w))
  return(w)
}

# define Markowitz mean-variance portfolio
library(CVXR) #install.packages("CVXR")
Markowitz_portfolio_fun <- function(data) {
  X <- diff(log(data$adjusted))[-1]  # compute log returns
  mu <- colMeans(X)  # compute mean vector
  Sigma <- cov(X)  # compute the SCM
  # design mean-variance portfolio
  w <- Variable(nrow(Sigma))
  prob <- Problem(Maximize(t(mu) %*% w - 0.5*quad_form(w, Sigma)),
                  constraints = list(w >= 0, sum(w) == 1))
  result <- solve(prob)
  return(as.vector(result$getValue(w)))
}
```

# Backtesting and Plots

## Backtesting your portfolios

With the dataset and portfolios ready, we can now do the backtest easily. For example, to obtain the three portfolios' performance over embedded dataset, we just need combine them in a list and finish all following work in one line
```{r, results = 'hide'}
portfolios <- list("Quintile"  = quintile_portfolio_fun,
                   "GMVP"      = GMVP_portfolio_fun,
                   "Markowitz" = Markowitz_portfolio_fun)
bt <- portfolioBacktest(portfolios, dataset10, benchmark = c("uniform", "index"))
```


## Result format
Here `bt` is a list storing all the backtest results according to your passed functions list.
```{r}
names(bt)
```
Each elements of `bt` is a list storing more informatrion ranking according to datasets, i.e.,
```{r, echo = FALSE}
library(data.tree)
tmp <- bt
for (i in 1:length(tmp))
  tmp[[i]] <- lapply(tmp[[i]], function(x){lapply(x, as.list)})
dt <- FromListSimple(tmp)
dt$name <- "bt"
print(dt, limit = 20)
```

Feel free to check your backtest results by directly exploring the returned `bt`. 


## Shaping your results
We also provide a series of functions to conveniently extract results:

* Select several performances of one specific portfolio:
```{r}
# select sharpe ratio and max drawdown performance of uniform portfolio
backtestSelector(bt, portfolio_name = "Quintile", 
                 selector = c("Sharpe ratio", "max drawdown"))
```
* Tables of several performance measures of the portfolios (classified by performance criteria):
```{r}
# show the portfolios performance in tables 
backtestTable(bt, selector = c("Sharpe ratio", "max drawdown"))
```
* Summary of performance measures:
```{r}
res_sum <- backtestSummary(bt)
names(res_sum)
res_sum$performance_summary 
```
For more flexible usage of these functions, you can refer to help pages of these functions. 


## Plotting your results
Besides, we also provide some functions to show results in figures.

* Performance table:
```{r}
summaryTable(res_sum, type = "DT")
```

<br>

* Barplot
```{r}
summaryBarPlot(res_sum, measures = c("Sharpe ratio", "max drawdown"))
```

<br>

* BoxPlot
```{r}
backtestBoxPlot(bt, measure = "Sharpe ratio")
```


# Advanced Usage

## Incoporating benchmarks
When perform the backtest of our designed portfolio functions, we may want to incorporate some benchmarks. Now the package suppport two benchmarks, which are `uniform portfolio` and `index` of the certain market. (Note that incorporating `index` benchmark requires each data item contain the index prices in an xts named `index`). We can easily do that in any case by passing corresponding value to argument `benchmark`.
```{r, cache=TRUE}
bt <- portfolioBacktest(portfolios, dataset10, benchmark = c('uniform', 'index'))
names(bt)
```

## Progress bar
In order to monitor the backtest progress, we add the progress bar display in all cases. Users can turn on the progress bar by setting argument `show_progress_bar` be `TRUE`.
```{r, eval = FALSE}
bt <- portfolioBacktest(portfolios, dataset10, show_progress_bar = TRUE)
```

## Parallel backtest
The backtest incurs very heavy computation load when numbers of portfolio functions or dataset go large. Therefore, we add support for parallel mode in this package. Users can choose if they want to parallel evaluate different portfolio functions or in a more fine-grained way, evaluating multiple datasets parallel for each function.
```{r, cache=TRUE}
portfun <- Markowitz_portfolio_fun

# parallel = 2 for functions
system.time(
  bt_nopar <- portfolioBacktest(list(portfun, portfun), dataset10)
  )
system.time(
  bt_parfuns <- portfolioBacktest(list(portfun, portfun), dataset10, paral_portfolios = 2)
  )

# parallel = 5 for datasets
system.time(
  bt_nopar <- portfolioBacktest(portfun, dataset10)
  )
system.time(
  bt_pardata <- portfolioBacktest(portfun, dataset10, paral_datasets = 5)
  )
```
It is obvious that the evaluation time for backtesting has been significantly reduced. Note that the parallel evaluation time can not be exactly equal to the original time divided by parallel cores because starting new R sessions also takes extra time. 

## Tracing where execution error happens
The execution error might happen without any clue. While our function is robustly designed to not be stopped by any error from the user defined function. To help user trace where the execution error happens, we also report the call stack when a execution error happens. Such information is given as the attribution `error_stack` of returned `error_message`.
For example, let's define a portfolio function which will throw a error:
```{r}
library(CVXR)
sub_function2 <- function(x) {
  "a" + x  # an error will happen here
}

sub_function1 <- function(x) {
  return(sub_function2(x))
}

wrong_portfolio_fun <- function(data) {
  N <- ncol(data$adjusted)
  uni_port <- rep(1/N, N)
  return(sub_function1(uni_port))
}
```
Then, we pass the above portfolio function into `portfolioBacktest()` and show how to check the error trace:
```{r}
bt <- portfolioBacktest(wrong_portfolio_fun, dataset10)
res <- backtestSelector(bt, portfolio_index = 1)

# information of 1st error
error1 <- res$error_message[[1]]
str(error1)

# the exact location of error happening
cat(attr(error1, "error_stack")$at)

# the call stack of error happening
cat(attr(error1, "error_stack")$stack)
```

## Backtesting over files: usage for grading students
When you have numbers of portfolio or some of them have conflicting dependencies, loading all of them into  your environment may not be a reasonable approach. Hence, we add support on doing backtest over files in our package. It suffices write each portfolio function into a .R script (with unique filename) containing the portfolio function called exactly `portfolio_fun()` as well as any other auxiliary functions that it may require (needless to say that the required packages should be loaded in that script with `library()`). Then all thees files should be put into a file folder, whose path will be passed to `portfolioBacktest()` through argument `folder_path`.
If an instructor wants to evaluate the students of a course in their portfolio design, it can also be done very easily by requiring each student submit a .R script with unique filenames like `STUDENTNUMBER.R`. For example, we have put three files in folder `portfolio_files`, namely `0001.R`, `0002.R`, `0003.R`.
```{r, cache=TRUE}
bt_all_students <- portfolioBacktest(folder_path = "portfolio_files", dataset = dataset10)
names(bt_all_students)
```

## Leaderboard of portfolios with user-defined ranking
Now we can rank the different portfolios/students based on a weighted combination of the rank percentiles (termed scores) of the performance measures:
```{r, fig.height=2, fig.width=9, out.width = "90%"}
leaderboard <- portfolioLeaderboard(bt_all_students, 
                                    weights = list("Sharpe ratio"  = 7, 
                                                   "max drawdown"  = 1, 
                                                   "annual return" = 1, 
                                                   "ROT bps"       = 1))

# show leaderboard
library(gridExtra)
grid.table(leaderboard$leaderboard_scores)
```


## Example of a script file to be submitted by a student
Consider the student with id number 666. Then the script file should be named `666.R` and should contain the portfolio function called exactly `portfolio_fun()` as well as any other auxiliary functions that it may require (needless to say that the required packages should be loaded in that script with `library()`):
```{r, eval=FALSE}
library(CVXR)

auxiliary_function <- function(x) {
  # here whatever code
}

portfolio_fun <- function(prices) {
  X <- as.matrix(diff(log(data$adjusted))[-1])  # compute log returns
  mu <- colMeans(X)  # compute mean vector
  Sigma <- cov(X)  # compute the SCM
  # design mean-variance portfolio
  w <- Variable(nrow(Sigma))
  prob <- Problem(Maximize(t(mu) %*% w - 0.5*quad_form(w, Sigma)),
                  constraints = list(w >= 0, sum(w) == 1))
  result <- solve(prob)
  return(as.vector(result$getValue(w)))
}
```


# Appendix

## Performance criteria

The definition of performance criteria used in this package is listed as below

 - **expected return:** the [annualized return](https://www.investopedia.com/terms/a/annualized-total-return.asp)
 - **volatility:** the [annualized standard deviation](https://www.fool.com/knowledge-center/how-to-calculate-annualized-volatility.aspx) of returns 
 - **max drawdown:** the maximum loss from a peak to a trough of a portfolio, see also [here](https://www.investopedia.com/terms/m/maximum-drawdown-mdd.asp)
 - **Sharpe ratio:** [annualized Sharpe ratio](https://en.wikipedia.org/wiki/Sharpe_ratio), the ratio between `annualized return` and `annualized standard deviation`
 - **Sterling ratio:** the return over average drawdown, see [here](https://en.m.wikipedia.org/wiki/Sterling_ratio) for complete definition. In the package, we use $$
 \text{Sterling ratio} = \frac{\text{annualized return}}{\text{max drawdown}} $$
 - **Omega ratio:** the probability weighted ratio of gains over losses for some threshold return target, see [here](https://en.m.wikipedia.org/wiki/Omega_ratio) for complete definition. The ratio is calculated as: $$ \Omega(r) = \frac{\int_{r}^{\infty} (1-F(x))dx}{\int_{-\infty}^{r} F(x)dx} $$
 In the package, we use $\Omega(0)$, which is also known as Gain-Loss-Ratio.
 
 - **Return over Turnover (ROT):** the sum of cummulative return over the sum of turnover.

## Future features

We plan to add the following features in our package:

 - **Transaction Cost**: the transaction cost will be deducted in calculating portfolio returns.
 - **Turnover Constraint**: compared with latest portfolio vector $\mathbf{w}_{t-1}$, your current portfolio $\mathbf{w}_{t}$ should be constrainted with limited changing, e.g., $\lVert \mathbf{w}_{t-1} - \mathbf{w}_{t} \rVert _{1} \le c$.




